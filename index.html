<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>Open-Meteo ë‚ ì”¨ ì§€ë„ (ìš¸ì‚°ë§Œ Â· ì•ˆì „ì •ë³´)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <style>
    html, body { height: 100%; margin: 0; }
    #map { height: 100vh; }
    .legend { position: absolute; z-index: 1000; right: 12px; bottom: 12px; background: rgba(255,255,255,.95); padding: 8px 10px; border-radius: 8px; font: 12px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; box-shadow: 0 2px 10px rgba(0,0,0,.1); max-width: 260px; }
    .legend div { display: flex; align-items: center; gap: 6px; margin: 3px 0; }
    .legend .sw { width: 10px; height: 10px; border-radius: 2px; display: inline-block; }
    .badge { display:inline-block; padding:2px 8px; border-radius:10px; font-weight:600; color:#fff }
    .muted { color:#666; font-size:12px }
    pre { white-space: pre-wrap; margin: 6px 0 0; }
    .toolbar { position:absolute; left:12px; top:12px; z-index:1000; background:rgba(255,255,255,.95); padding:8px 10px; border-radius:8px; box-shadow:0 2px 10px rgba(0,0,0,.1); font: 13px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial; }
    .toolbar button{ cursor:pointer; border:1px solid #e5e7eb; background:#fff; padding:6px 10px; border-radius:8px }
  </style>
</head>
<body>
  <div id="map"></div>
  <div class="toolbar">
    <button id="refreshBtn">â†» ìƒˆë¡œê³ ì¹¨</button>
    <span id="updated" class="muted" style="margin-left:8px">ì—…ë°ì´íŠ¸ ëŒ€ê¸°â€¦</span>
  </div>

  <div class="legend">
    <b>ìœ„í—˜ë„</b>
    <div><span class="sw" style="background:#10b981"></span> ë‚®ìŒ</div>
    <div><span class="sw" style="background:#3b82f6"></span> ë³´í†µ</div>
    <div><span class="sw" style="background:#f59e0b"></span> ì£¼ì˜</div>
    <div><span class="sw" style="background:#dc2626"></span> ê²½ê³„</div>
    <div><span class="sw" style="background:#b91c1c"></span> ì‹¬ê°</div>
  </div>

  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script>
    // ===== ê¸°ë³¸ ìƒìˆ˜ =====
    const KST = 'Asia/Seoul';
    const CONCURRENCY = 1; // ìš¸ì‚°ë§Œ ì¡°íšŒ
    const FETCH_TIMEOUT_MS = 12000;

    // ===== Open-Meteo URL ì¡°ë¦½ (ë°±í‹± ì‚¬ìš©) =====
    const OPEN_METEO = ({lat, lon}) => `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}`
      + `&models=kma_seamless&current=temperature_2m,relative_humidity_2m,is_day,weather_code,rain,showers,snowfall,wind_speed_10m`
      + `&timezone=${encodeURIComponent(KST)}&windspeed_unit=ms`;

    // âœ… ìš¸ì‚°ë§Œ ë‚¨ê¹€
    const cities = [ { name: 'ìš¸ì‚°', lat: 35.5557413, lon: 129.333016 } ];

    // ===== ìœ í‹¸ =====
    const sleep = (ms) => new Promise(r => setTimeout(r, ms));
    const withTimeout = (p, ms) => Promise.race([ p, new Promise((_, rej) => setTimeout(() => rej(new Error('timeout')), ms)) ]);
    const fmt = (n, dp=0) => (n===undefined || n===null || Number.isNaN(n)) ? '-' : Number(n).toFixed(dp);
    const nowStr = () => new Date().toLocaleString('ko-KR', { timeZone: KST });

    function weatherFromCode(code) {
      if (code === 0) return { main: 'Clear', description: 'ë§‘ìŒ' };
      if ([1,2,3].includes(code)) return { main: 'Clouds', description: code===1?'ëŒ€ì²´ë¡œ ë§‘ìŒ': code===2?'ë¶€ë¶„ íë¦¼':'íë¦¼' };
      if ([45,48].includes(code)) return { main: 'Fog', description: 'ì•ˆê°œ/ì§™ì€ ì•ˆê°œ' };
      if ([51,53,55,56,57].includes(code)) return { main: 'Drizzle', description: 'ì´ìŠ¬ë¹„/ì–¸ ì´ìŠ¬ë¹„' };
      if ([61,63,65,66,67,80,81,82].includes(code)) return { main: 'Rain', description: 'ë¹„/ì†Œë‚˜ê¸°' };
      if ([71,73,75,77,85,86].includes(code)) return { main: 'Snow', description: 'ëˆˆ/ì†Œë‚™ëˆˆ' };
      if ([95,96,99].includes(code)) return { main: 'Thunderstorm', description: 'ë‡Œìš°' };
      return { main: 'Clouds', description: 'íë¦¼' };
    }

    function colorForLevel(level) {
      return level === 'ì‹¬ê°' ? '#b91c1c'
        : level === 'ê²½ê³„' ? '#dc2626'
        : level === 'ì£¼ì˜' ? '#f59e0b'
        : level === 'ë³´í†µ' ? '#3b82f6'
        : '#10b981';
    }

    function assessHazard({ main, tempC, windMs, rainMm, snowMm }) {
      let level = 'ë³´í†µ';
      let type = main;
      let tips = [];
      const set = (lvl, typ, arr) => { level = lvl; type = typ; tips = arr.slice(); };

      if (main === 'Thunderstorm') {
        set(rainMm > 10 ? 'ì‹¬ê°' : 'ê²½ê³„', 'ë‡Œìš°/í˜¸ìš°', [
          'ê°•í•œ ë¹„Â·ë²ˆê°œ ì‹œ ìš´í–‰ ì¤‘ì§€, ì‹¤ë‚´ ëŒ€ê¸°',
          'ì§€í•˜ì°¨ë„Â·í•˜ì²œ ì¸ê·¼ ì¹¨ìˆ˜ ë„ë¡œ ì§„ì… ê¸ˆì§€',
          'ì‹œì•¼ ê¸‰ê°: ì†ë„ 30% ê°ì†(ë¹„ìƒë“±ì€ ì •ì°¨ ì‹œ ì‚¬ìš©)'
        ]);
      } else if (main === 'Rain' || main === 'Drizzle') {
        set(rainMm > 30 ? 'ì‹¬ê°' : rainMm > 10 ? 'ê²½ê³„' : 'ì£¼ì˜', 'ë¹„/ì –ì€ ë…¸ë©´', [
          'ê°ì†(í‰ì†Œ ëŒ€ë¹„ 20~30%), ì œë™ê±°ë¦¬ 2ë°°',
          'ë§¨í™€Â·ë„ìƒ‰Â·ì² íŒÂ·ë¹—ë¬¼ë°›ì´ ìœ„ í†µê³¼ ê¸ˆì§€',
          'í—¬ë©§ ê¹€ì„œë¦¼ ë°©ì§€, ë°©ìˆ˜ ì¥ê°‘ ì°©ìš©'
        ]);
      } else if (main === 'Snow') {
        set(snowMm > 5 ? 'ê²½ê³„' : 'ì£¼ì˜', 'ëŒ€ì„¤/ê²°ë¹™', [
          'ë¸”ë™ì•„ì´ìŠ¤ ì‹œê°„ëŒ€ ìš´í–‰ ìì œÂ·ê·¼ë¬´ì‹œê°„ ì¡°ì •',
          'ê¸‰ê°€ê°ì† ê¸ˆì§€, ì§ì§„ ì‹œ í›„ë¥œ ì œë™ ë¹„ì¤‘ ë‚®ì¶”ê¸°',
          'ë°©í•œ ì¥ë¹„ ì°©ìš©, ì²´ì˜¨ ì €í•˜ ì‹œ ì¦‰ì‹œ íœ´ì‹'
        ]);
      } else if (main === 'Clear') {
        if (tempC >= 35) {
          set('ê²½ê³„', 'í­ì—¼', [
            '30~60ë¶„ ê°„ê²© ê·¸ëŠ˜ íœ´ì‹Â·ìˆ˜ë¶„ ë³´ì¶©',
            'í†µí’í˜• ìì¼“/ì´ë„ˆ, ì¿¨ë§ íƒ€ì›” í™œìš©',
            'ì–´ì§€ëŸ¼Â·ë‘í†µ ë“± ì—´ì§ˆí™˜ ì§•í›„ ì‹œ ì¦‰ì‹œ ì¤‘ì§€'
          ]);
        } else if (tempC >= 33) {
          set('ì£¼ì˜', 'í­ì—¼', [
            'ê·¸ëŠ˜ íœ´ì‹Â·ìˆ˜ë¶„ ë³´ì¶©',
            'ì§„í•œ ìƒ‰/ë‘êº¼ìš´ ì¥ë¹„ í”¼í•˜ê¸°',
            'ì¹´í˜ì¸ ê³¼ë‹¤ì„­ì·¨ ìì œ'
          ]);
        } else if (tempC <= -10) {
          set('ê²½ê³„', 'í•œíŒŒ', [
            'í•¸ë“¤ì›Œë¨¸/í† ì‹œÂ·í•«íŒ©ìœ¼ë¡œ ì† ê°ê° ìœ ì§€',
            'ì•„ì¹¨ êµëŸ‰Â·ê·¸ëŠ˜ê¸¸ ë¸”ë™ì•„ì´ìŠ¤ ì£¼ì˜, ì„œí–‰',
            'ì‹œë™ ì „ íƒ€ì´ì–´ ê³µê¸°ì••Â·ê· ì—´ ì ê²€'
          ]);
        } else {
          set('ë‚®ìŒ', 'ë§‘ìŒ', [ 'PPE(í’€í˜ì´ìŠ¤ í—¬ë©§Â·ì¥ê°‘Â·ë¶€ì¸ Â·ë³´í˜¸ëŒ€) í•„ìˆ˜ ì°©ìš©' ]);
        }
      } else if (main === 'Clouds') {
        set('ë³´í†µ', 'êµ¬ë¦„/ê±´ì¡° ë…¸ë©´', [ 'ê·œì • ì†ë„Â·ì°¨ê°„ê±°ë¦¬ 3ì´ˆ ì´ìƒ, í”¼ë¡œ ëˆ„ì  ì‹œ íœ´ì‹' ]);
      } else if (main === 'Fog') {
        set('ì£¼ì˜', 'ì•ˆê°œ/ë°•ë¬´', [
          'ì €ì† ì£¼í–‰, ìƒì‹œ ë¡œìš°ë¹”/ì•ˆê°œë“±',
          'ì°¨í­ ìœ ì§€(ì¤‘ì•™ì„ Â·ê°“ê¸¸ ì ‘ê·¼ ê¸ˆì§€)',
          'ì°¨ë¡œ ë³€ê²½ ìµœì†Œí™”, ì°¨ê°„ê±°ë¦¬ 4ì´ˆ+'
        ]);
      }

      if (windMs >= 14) {
        const windLevel = windMs >= 20 ? 'ì‹¬ê°' : 'ê²½ê³„';
        set(windLevel, 'ê°•í’/ëŒí’', [
          'íš¡í’ êµ¬ê°„(êµëŸ‰Â·í•´ì•ˆÂ·ê³ ê°€) íšŒí”¼, í†µê³¼ ì‹œ ì €ì†Â·ì°¨ë¡œ ì¤‘ì•™',
          'ëŒ€í˜•ì°¨ ì¶”ì›” ê¸ˆì§€(ì™€ë¥˜ ìœ„í—˜), ì ì¬ë¬¼ ì¬ê²°ì†',
          'ì°¨ì²´ë¥¼ ë°”ëŒ ë°©í–¥ìœ¼ë¡œ ì•½ê°„ ê¸°ìš¸ì—¬ ê· í˜• ìœ ì§€'
        ]);
      }

      tips.push('ê³µí†µ: T-CLOCS ì ê²€, PPE ì°©ìš©, ì°¨ê°„ê±°ë¦¬ 3~4ì´ˆ, ì ì¬ ê· í˜• ìœ ì§€');
      return { level, type, tips };
    }

    // ===== ì§€ë„ ì´ˆê¸°í™” â€” ìš¸ì‚° ì¤‘ì‹¬ìœ¼ë¡œ =====
    const map = L.map('map').setView([35.5557413, 129.333016], 11);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      attribution: 'Â© OpenStreetMap contributors',
      maxZoom: 19
    }).addTo(map);

    const markerLayer = L.layerGroup().addTo(map);
    const circleLayer = L.layerGroup().addTo(map);
    const updatedEl = document.getElementById('updated');

    function cityPopup({name, wc, temp, humidity, wind, rain, snow, hazard}) {
      const badge = `<span class="badge" style="background:${colorForLevel(hazard.level)}">${hazard.level}</span>`;
      const tipsList = hazard.tips.map(t => `- ${t}`).join('\n');

      // âœ… ì¶”ê°€ ì•ˆì „ì •ë³´ (ìš”ì²­ì‚¬í•­ ë°˜ì˜)
      let incidentHtml = '';
      const main = wc.main; // 'Rain', 'Drizzle', 'Thunderstorm', 'Snow', ...
      if (['Rain', 'Drizzle', 'Thunderstorm'].includes(main)) {
        incidentHtml = `
          <div style="margin-top:6px;padding:8px 10px;border:1px solid #e5e7eb;border-radius:8px;background:#fafafa">
            <div style="font-weight:700;">âš ï¸ ì¶”ê°€ ì•ˆì „ì •ë³´</div>
            <div>ì•ˆì „ì‚¬ê³  : <b>4ê±´</b></div>
            <div style="margin-top:4px">ì‚¬ê³ ì‚¬ë¡€ : ìš°í¸ë¬¼ ë°°ì†¡ì¤‘, ì „ë°©ì—ì„œ ê°‘ìê¸° ìš°íšŒì „ ì°¨ëŸ‰ì´ ë‚˜íƒ€ë‚˜ ì¶©ëŒì„ í”¼í•˜ë ¤ê³  ë¸Œë ˆì´í¬ë¥¼ ë°Ÿì•˜ìœ¼ë‚˜ ë¹—ê¸¸ì— ë¯¸ë„ëŸ¬ì ¸ ì™¼ìª½ ì—‰ì¹˜ë¼ˆì™€ í—ˆë²…ì§€ì— ì°°ê³¼ìƒ ë°œìƒ</div>
          </div>`;
      } else if (main === 'Snow') {
        incidentHtml = `
          <div style="margin-top:6px;padding:8px 10px;border:1px solid #e5e7eb;border-radius:8px;background:#fafafa">
            <div style="font-weight:700;">âš ï¸ ì¶”ê°€ ì•ˆì „ì •ë³´</div>
            <div>ì•ˆì „ì‚¬ê³  : <b>4ê±´</b></div>
            <div style="margin-top:4px">ì‚¬ê³ ì‚¬ë¡€ : ë°°ë‹¬ì„ ìœ„í•´ ì´ë¥œì°¨ë¡œ ì»¤ë¸Œê¸¸ì„ ì§€ë‚˜ê°€ë˜ ì¤‘, ë¸”ë™ì•„ì´ìŠ¤ì— ë¯¸ë„ëŸ¬ì ¸ ë„˜ì–´ì ¸ ì˜¤ë¥¸ìª½ ì–´ê¹¨ ë° íŒ”ê¿ˆì¹˜ë¥¼ ì°”ê³¼ìƒ ë°œìƒ</div>
          </div>`;
      }

      return `ğŸ“ <b>${name}</b><br/>
        ğŸŒ¤ï¸ ìƒíƒœ: ${wc.description}
        <span style="display:inline-block;padding:2px 6px;border-radius:10px;border:1px solid #cfe;color:#456;background:#eef;margin-left:4px">${wc.main}</span><br/>
        ğŸŒ¡ï¸ ê¸°ì˜¨: <b>${fmt(temp,0)}Â°C</b> Â· ğŸ’§ ìŠµë„: ${fmt(humidity,0)}% Â· ğŸŒ¬ï¸ í’ì†: ${fmt(wind,1)} m/s<br/>
        ğŸŒ§ï¸ ê°•ìˆ˜(í˜„ì¬): ${fmt(rain,1)} mm Â· â„ï¸ ì ì„¤(í˜„ì¬): ${fmt(snow,1)} mm<br/><br/>
        <b>ğŸ›¡ï¸ ì´ë¥œì°¨ ì˜ˆë°©ì±…</b> ${badge}<br/>
        ìƒí™© ë¶„ë¥˜: <b>${hazard.type}</b>
        <pre>${tipsList}</pre>
        ${incidentHtml}
        <div class="muted">* ë°ì´í„°: Open-Meteo(kma_seamless) Â· ì‹œê°„ëŒ€: ${KST}</div>`;
    }

    async function fetchCityWeather(city, retries=1) {
      const url = OPEN_METEO(city);
      try {
        const res = await withTimeout(fetch(url), FETCH_TIMEOUT_MS);
        if (!res.ok) throw new Error(`Open-Meteo ì˜¤ë¥˜: ${res.status}`);
        const data = await res.json();
        const cur = data.current || {};
        const wc = weatherFromCode(cur.weather_code ?? 3);
        const temp = cur.temperature_2m;
        const humidity = cur.relative_humidity_2m;
        const wind = cur.wind_speed_10m;
        const rain = Math.max(cur.rain ?? 0, cur.showers ?? 0);
        const snow = cur.snowfall ?? 0;
        const hazard = assessHazard({ main: wc.main, tempC: temp, windMs: wind, rainMm: rain, snowMm: snow });
        return { wc, temp, humidity, wind, rain, snow, hazard };
      } catch (e) {
        if (retries > 0) {
          await sleep(400 + Math.random()*600);
          return fetchCityWeather(city, retries-1);
        }
        throw e;
      }
    }

    function drawCity(city, info) {
      const marker = L.marker([city.lat, city.lon]).addTo(markerLayer);
      marker.bindPopup(cityPopup({ name: city.name, ...info }));

      const radius = 16;
      const color = colorForLevel(info.hazard.level);
      L.circleMarker([city.lat, city.lon], { radius, color, fillColor: color, fillOpacity: 0.25 }).addTo(circleLayer);
    }

    async function render(batch = cities) {
      const updatedEl = document.getElementById('updated');
      markerLayer.clearLayers();
      circleLayer.clearLayers();
      if (updatedEl) updatedEl.textContent = 'ë¶ˆëŸ¬ì˜¤ëŠ” ì¤‘â€¦';

      try {
        const chunks = [];
        for (let i=0; i<batch.length; i+=CONCURRENCY) chunks.push(batch.slice(i, i+CONCURRENCY));

        for (const group of chunks) {
          const results = await Promise.allSettled(
            group.map(async city => {
              const info = await fetchCityWeather(city);
              drawCity(city, info);
              return { city, ok: true };
            })
          );

          results.forEach((r, idx) => {
            if (r.status === 'rejected') {
              const city = group[idx];
              const m = L.marker([city.lat, city.lon]).addTo(markerLayer);
              m.bindPopup(`âŒ <b>${city.name}</b><br/>ë‚ ì”¨ ì •ë³´ë¥¼ ë¶ˆëŸ¬ì˜¬ ìˆ˜ ì—†ìŠµë‹ˆë‹¤.`);
            }
          });
          await sleep(150);
        }
      } catch (err) {
        console.error('ë Œë”ë§ ì˜¤ë¥˜:', err);
        if (updatedEl) updatedEl.textContent = `ì˜¤ë¥˜: ${err?.message ?? err}`;
        return;
      }
      if (updatedEl) updatedEl.textContent = `ì—…ë°ì´íŠ¸: ${nowStr()}`;
    }

    document.getElementById('refreshBtn').addEventListener('click', () => render());
    render();
  </script>
</body>
</html>
